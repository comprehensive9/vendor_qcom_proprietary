/*
 * Copyright (c) 2019-2022 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

#include <stdint.h>
#include <stdio.h>

#include <keymaster_defs.h>
#include <keymaster.h>
#include <keymaster_utils.h>

#include "sample_utils.h"

static uint8_t IV[128/8] = {0x01};

//just an attempt for km_begin operation with the AES key. (will abort the operation in case of success.)
static keymaster_error_t attempt_begin(const keymaster_key_blob_t* key_blob)
{
    keymaster_operation_handle_t op_handle;

    keymaster_key_param_t op_params[] = {
            keymaster_param_enum(KM_TAG_PADDING, KM_PAD_PKCS7),
            keymaster_param_enum(KM_TAG_BLOCK_MODE, KM_MODE_CBC),
            keymaster_param_blob(KM_TAG_NONCE, IV, sizeof(IV))
    };
    keymaster_key_param_set_t op_params_set = {
            .params = op_params,
            .length = sizeof(op_params)/sizeof(op_params[0]),
    };

    keymaster_key_param_set_t op_out_params_set = {0};

    keymaster_error_t err = km_begin(KM_PURPOSE_ENCRYPT, key_blob, &op_params_set, &op_out_params_set, &op_handle);
    if (err != KM_ERROR_OK)
        return err;

    err = km_abort(op_handle);

    return err;
}

/*************************************************************************************/
/* UPGRADE */
/*************************************************************************************/
keymaster_error_t keymaster_key_upgrade_sample(void) {
    keymaster_error_t err = KM_ERROR_UNKNOWN_ERROR;
    //holds key material generated by keymaster
    keymaster_key_blob_t old_key_blob = { 0 };
    do {

        err = get_old_aes_key(&old_key_blob);
        if (err != KM_ERROR_OK)
            printf("Error encountered during create_aes_key : %d\n", err);
        if (err != KM_ERROR_OK)
            break;

        err = initialize_keymaster();
        if (err != KM_ERROR_OK) {
            printf("Error encountered during re-initialize_keymaster : %d\n", err);
            break;
        }

        //try to start encrypt operation with old blob
        err = attempt_begin(&old_key_blob);

        //expect it to fail and return "key upgrade required"
        if (err != KM_ERROR_KEY_REQUIRES_UPGRADE) {
            printf("ERROR: km_begin() was expected to return KM_ERROR_KEY_REQUIRES_UPGRADE (%d). (actual: %d)\n",
                KM_ERROR_KEY_REQUIRES_UPGRADE, err);
            printf("Make sure the OS version/patch passed during initialization differ from the values\n");
            printf("embedded in the old key material.\n");
            //return error to make sure the sample fails even if OK was returned (which is unexpected)
            err == KM_ERROR_OK ? KM_ERROR_UNKNOWN_ERROR : err;
            goto exit;
        }
        printf("km_begin() returned with KM_ERROR_KEY_REQUIRES_UPGRADE as expected for old key.\n");

        //upgrade key blob
        keymaster_key_blob_t upgraded_key_blob = { 0 };
        err = km_upgrade_key(&old_key_blob, NULL, &upgraded_key_blob);
        if (err != KM_ERROR_OK) {
            printf("ERROR: km_upgrade_key() was expected to return KM_ERROR_OK (%d). (actual: %d)\n", KM_ERROR_OK, err);
            goto exit;
        }

        //try to start operation with the upgraded blob
        err = attempt_begin(&upgraded_key_blob);
        keymaster_free_key_blob(&upgraded_key_blob);

        if (err != KM_ERROR_OK) {
            printf("ERROR: attempt_begin() was expected to return KM_ERROR_OK (%d). (actual: %d)\n", KM_ERROR_OK, err);
            goto exit;
        }

        printf("km_begin() successful with upgraded key.\n");
        printf("Key upgrade sample completed successfully!\n");
    } while (0);

    if (err != KM_ERROR_OK) {
        printf("Error encountered during keymaster key upgrade sample: %d\n", err);
    }

exit:
    //memory cleanup
    keymaster_free_key_blob(&old_key_blob);

	km_close();

    return err;
}
